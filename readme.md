# Concurrent Hash Map

В этой задаче вам предстоит реализовать поддерживающую многопоточность хеш-таблицу.
Таблица поддерживает отображение ключ -> значение, где каждому ключу ставится в
соответствие единственное значение.

Базовая реализация находится в файле `concurrent_hash_map.h`. Эта реализация использует
`std::unordered_map` и мьютекс для блокирования перед всеми операциями, что неэффективно
при наличии большого числа потоков, одновременно работающих с таблицей.

Обратите внимание, что метод цепочек дает способ блокировать не всю таблицу --- ведь очередная операция
работает только с одним списком. Однако при этом нужно аккуратно выполнять рехеширование при
заполнении таблицы.

Вы можете использовать идею из предыдущего абзаца для реализации более эффективной таблицы.
Ваша реализация должна содержать тот же интерфейс, что и приведенная базовая. Несколько комментариев по нему:

1. `expected_size` в конструкторах лишь подсказка для вашего класса --- реальное число вставленных элементов
может быть и больше, и меньше (аналог `reserve`).
2. Аналогично, `expected_threads_count` --- ожидаемое число потоков, работающих с таблицей одновременно, ---
тоже лишь подсказка (впрочем, обычно соответствующая действительности).
3. Константа `kUndefinedSize` используется, когда размер таблицы заранее неизвестен, а число потоков известно.
4. `hasher` (по умолчанию объект класса `std::hash`) осуществляет отображение из пространства ключей в `size_t`.
Вы можете считать, что хешер распределяет ключи по `size_t` достаточно хорошо. Впрочем, если это не так, это не
должно приводить к неработоспособности таблицы. В таком случае должно ухудшаться только время работы (и, возможно, потребляемая память).
5. `Erase` и `Insert` возвращают `true` в случае успешного удаления/вставки. Если элемент с таким ключом уже есть, то `Insert` не должен ничего
делать.
